---
layout: post
title: JavaScript内存泄漏
description: "Sample post with a background image CSS override."
tags: [JavaScript, 内存泄漏]
image:
  background: triangular.png
comments: true
share: true
---


<h1>简介</h1>

所谓内存泄露就是内存空间使用完毕之后未回收。在过去Web开发人员并没有太多的去关注内存泄露问题.那时的页面间联系大都比较简单，js使用的功能主要是表单校验，不会有太多关于特效以及业务等方面上的扩展，而进入WEB 2.0 时代，js人们对Web应用有了高更的要求.一个页面很可能数小时不会发生URL跳转，并同时通过Web服务动态的更新页面内容.复杂的事件关联设计、基于对象的JScript和DHTML技术的广泛采用，使得代码的能力达到了其承受的极限.在这样的情况和改变下，弄清楚内存泄露方式变得非常的急迫。那么，为什么会出现内存溢出呢？
							
<h1>内存分配与垃圾回收</h1>

说道内存泄露，就不得不谈到内存分配的方式。内存分配有三种方式，分别是：
<h2>静态分配(Static Allocation )</h2>
静态变量和全局变量的分配形式。如果把房间看做一个程序，我们可以把静态分配的内存当成是房间里的耐用家具。通常，它们无需释放和回收，因为没人会天天把大衣柜当作垃圾扔到窗外。
<h2>自动分配( Automatic Allocation )</h2>
在栈中为局部变量分配内存的方法。栈中的内存可以随着代码块退出时的出栈操作被自动释放。
这类似于到房间中办事的人，事情一旦完成，就会自己离开，而他们所占用的空间，也随着这些人的离开而自动释放了。
<h2>动态分配( Dynamic Allocation )</h2>
在堆中动态分配内存空间以存储数据的方式。也就是程序运行时用malloc或new申请的内存，我们需要自己用free或delete释放。动态内存的生存期由程序员自己决定。一旦忘记释放，势必造成内存泄露。这种情况下，堆中的内存块好像我们日常使用的餐巾纸，用过了就得扔到垃圾箱里，否则屋内就会满地狼藉。因此，懒人们做梦都想有一台家用机器人跟在身边打扫卫生。在软件开发中，如果你懒得释放内存，那么你也需要一台类似的机器人——这其实就是一个由特定算法实现的垃圾收集器。而正是垃圾收集机制本身策略的一些缺陷，导致了javascript内存泄漏。具体到浏览器中的实现，通常有以下两个策略：
<h3>标记清除</h3>
Javascript最常用的垃圾回收方式是“标记清除”(mark-and-sweep)。当变量进入环境（如在函数中声明了一个变量），则为其标记为“进入环境”；当变量离开环境，则为其标记为“离开环境”。垃圾回收器会定时扫描那些“离开环境”的变量，销毁那些被标记的值并回收它们所占的内存。
除了IE7以前的版本、Netscape Navigate3.0,其他版本的浏览器都用的是标记清除的垃圾回收策略。
<h3>引用计数</h3>
引用计数的含义是跟踪记录每个值被引用的次数，如当声明一个变量并将一个引用类型赋给该变量时，这个值的引用次数就是1，如果这个引用类型赋给另一个变量，它的引用类型加1,。相反，如果第一个变量又引用了其他引用类型时，之前的引用类型的引用次数就减1，直到减成0。当垃圾回收下一次运行的时候，就会释放掉引用次数为0的引用类型的内存。
该方式有一个严重的问题，请看下面例子：
{% highlight JavaScript %}
{% raw %}
function problem(){
	var objA = {};
	var objB = {}; 
	
	objA.someOtherObject = objB;
	objB.anotherObject = objA;
}
{% endraw %}
{% endhighlight %}
